<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>tutorial | Home to artivis</title><link>https://artivis.github.io/tag/tutorial/</link><atom:link href="https://artivis.github.io/tag/tutorial/index.xml" rel="self" type="application/rss+xml"/><description>tutorial</description><generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><copyright>Jérémie Deray © 2020</copyright><lastBuildDate>Mon, 01 Jun 2020 00:00:00 +0000</lastBuildDate><image><url>https://artivis.github.io/images/icon_hud2d1771ce140e1d1fd4d0e59d51cebc4_11712_512x512_fill_lanczos_center_2.png</url><title>tutorial</title><link>https://artivis.github.io/tag/tutorial/</link></image><item><title>Managing dotfiles</title><link>https://artivis.github.io/post/2020/dotfiles/</link><pubDate>Mon, 01 Jun 2020 00:00:00 +0000</pubDate><guid>https://artivis.github.io/post/2020/dotfiles/</guid><description>&lt;p>In this post, we will see how we can easily manage our personal
configuration files - a.k.a. dotfiles.
Yeah dotfiles, named after there common &lt;code>~/.my_config&lt;/code> form, you know,
all of those small configuration files lying across our $HOME.&lt;/p>
&lt;blockquote>
&lt;p>Because there is no place like $HOME&lt;/p>
&lt;/blockquote>
&lt;p>Because we are spending so much time on our machine, be it for work or for fun
(both at the same time if you are lucky),
we love to tweak our environment to our taste and needs.
Change the UX, create some aliases, use some dark theme and what not,
most if not all of these is saved in some configuration files somewhere.
And since we spent so much time making a home for ourselves,
wouldn&amp;rsquo;t it be great if we could quickly set it up again on a different computer?
Change the house but keep the furniture and decorations?
This is precisely what we are going to set up here.&lt;/p>
&lt;h1 id="picking-dotfiles-manager">Picking dotfiles manager&lt;/h1>
&lt;p>Looking on the web for a dotfiles manager, you my find many of them -
see a whole
&lt;a href="https://dotfiles.github.io/utilities/" target="_blank" rel="noopener">list of them here&lt;/a>. Most of them work off
the same principles, being a small set of utils to help manage our dotfiles.
Management includes most importantly versioning, often through git and
the installation of the files to their correct location as they are more than
often expected to be found at a given path.
You may want to give a look at aforementioned list of managers
and pick to one that best answer your needs and expectations.
Note that many are interchangeable.&lt;/p>
&lt;p>In this post we settled using
&lt;a href="https://github.com/andsens/homeshick" target="_blank" rel="noopener">&lt;code>homeshick&lt;/code>&lt;/a>.
There are two main reasons to this choice.
Firstly, it is entirely written in bash, making it usable virtually anywhere.
Secondly, it &amp;lsquo;installs&amp;rsquo; dotfiles on our system using symlinks rather than
hard copies. The files thus exist in a single place.
Some other nice features includes, being git-based, being cli-based,
supporting multi dotfiles repos.
It has to be noted tho that the project is not in a really active
development and not very feature rich compared to other solutions.
It is a thin-layer that does the job.&lt;/p>
&lt;p>Alright so how do we get started?&lt;/p>
&lt;h1 id="building-our-castle">Building our castle&lt;/h1>
&lt;p>&lt;code>homeshick&lt;/code> relies around the concept of &lt;em>castles&lt;/em> which are nothing
more than git repositories.
A castle contains all of our dotfiles which are organized with the same
layout as our home directory.
But before building our castle, we need to install the appropriate tool.
To install &lt;code>homeshick&lt;/code>, nothing easier, we simply clone its repository
in our home:&lt;/p>
&lt;pre>&lt;code class="language-bash">$ git clone https://github.com/andsens/homeshick.git $HOME/.homesick/repos/homeshick
&lt;/code>&lt;/pre>
&lt;p>And we are done. Now to use it, we only have to source it,
e.g. directly in our &lt;code>.bashrc&lt;/code>,&lt;/p>
&lt;pre>&lt;code class="language-bash">$ echo &amp;quot;source ~/.homesick/repos/homeshick/homeshick.sh&amp;quot; &amp;gt;&amp;gt; ~/.bashrc
&lt;/code>&lt;/pre>
&lt;p>We can also source its tab completion tool to ease our life,&lt;/p>
&lt;pre>&lt;code class="language-bash">$ echo &amp;quot;source ~/.homesick/repos/homeshick/completions/homeshick-completion.bash&amp;quot; &amp;gt;&amp;gt; ~/.bashrc
&lt;/code>&lt;/pre>
&lt;p>Alright, we are done with the installation,
let us start creating the said castle.&lt;/p>
&lt;p>First we create a new local git repo through &lt;code>homeshick&lt;/code> cli tool,&lt;/p>
&lt;pre>&lt;code class="language-bash">$ homeshick generate dotfiles
&lt;/code>&lt;/pre>
&lt;p>This creates an empty castle named &amp;lsquo;dotfiles&amp;rsquo; in
&lt;code>~/.homesick/repos/dotfiles/&lt;/code>.
To populate our castle with a dotfile, we make use of the &amp;lsquo;track&amp;rsquo; command:&lt;/p>
&lt;pre>&lt;code class="language-bash">$ homeshick track {castle} {dotfile}
&lt;/code>&lt;/pre>
&lt;p>To track our first file, say e.g. &lt;code>.bashrc&lt;/code>, we simply issue,&lt;/p>
&lt;pre>&lt;code class="language-bash">$ homeshick track dotfiles ~/.bashrc
&lt;/code>&lt;/pre>
&lt;p>The command copies the file in our castle at
&lt;code>~/.homesick/repos/dotfiles/home/.bashrc&lt;/code> and replaces the original file
with a symlink to the copy.&lt;/p>
&lt;p>Now all we have to do is to commit our change and save our castle online,&lt;/p>
&lt;p>To move to our local repository, we enter,&lt;/p>
&lt;pre>&lt;code class="language-bash">$ homeshick cd dotfiles
&lt;/code>&lt;/pre>
&lt;p>and we can now use the usual git commands,&lt;/p>
&lt;pre>&lt;code class="language-bash">$ git add .
$ git commit -m 'add .bashrc'
&lt;/code>&lt;/pre>
&lt;p>Let us save our castle online, e.g. on GitHub,&lt;/p>
&lt;pre>&lt;code class="language-bash">$ git remote add origin git@github.com:user/dotfiles.git
$ git push -u origin master
&lt;/code>&lt;/pre>
&lt;p>We may now repeat this operation for each and every configuration file
we would like to save.
With our castle safely backed up online, we will now see
how we can quickly set up our environment on a new machine.&lt;/p>
&lt;h1 id="quickly-setting-up-a-new-machine">Quickly setting up a new machine&lt;/h1>
&lt;p>Whether you bought a new computer or nuked your old hardware with a
fresh new distro, you will now witness the true power of &lt;code>homeshick&lt;/code>.&lt;/p>
&lt;p>To install our cosy environment on a fresh distro,
all we have to do is,&lt;/p>
&lt;ol>
&lt;li>Install &lt;code>homeshick&lt;/code>
&lt;pre>&lt;code class="language-bash">$ git clone https://github.com/andsens/homeshick.git $HOME/.homesick/repos/homeshick
$ source ~/.homesick/repos/homeshick/homeshick.sh
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>Import our castle
&lt;pre>&lt;code class="language-bash">$ homeshick clone git@github.com:user/dotfiles.git
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>Let &lt;code>homeshick&lt;/code> works its magic
&lt;pre>&lt;code class="language-bash">$ homeshick link dotfiles
&lt;/code>&lt;/pre>
&lt;/li>
&lt;/ol>
&lt;p>Voila! Home sweet home.&lt;/p>
&lt;p>Of course this post is only a quick overview of a given dotfiles manager.
I won&amp;rsquo;t detail here all of its options and features
and let discover them for yourself in its
&lt;a href="https://github.com/andsens/homeshick/wiki" target="_blank" rel="noopener">wiki&lt;/a>.
As mentioned previously many dotfiles managers rely on a git repository and the
same layout as &lt;code>homeshick&lt;/code> so you can get started with it and later move to
another one which better fits you needs.&lt;/p>
&lt;p>At this point you may be wondering if this it really worth it given that you probably
install a fresh distro every 2 years or so and completely change hardware even less
frequently.
Well, fellow developer, aren&amp;rsquo;t you using containers?
If not, you definitely should consider it and check
&lt;a href="https://artivis.github.io/post/2020/lxc">this other post&lt;/a>
were I detail development workflow for
&lt;a href="https://www.ros.org/" target="_blank" rel="noopener">ROS&lt;/a> in
&lt;a href="https://linuxcontainers.org/" target="_blank" rel="noopener">LXD&lt;/a>.&lt;/p>
&lt;h1 id="disposable-tiny-home">Disposable tiny home&lt;/h1>
&lt;p>If you are like me, trying your best to keep a tidy laptop while
messing around with plenty of different software toys,
then you may have had one of this day during which you spawn several containers.
Containers in which we don&amp;rsquo;t have our sweet bash aliases;
on our very own machine!
But thanks to &lt;code>homeshick&lt;/code> we can now start up a fresh
container and have it mimic &lt;code>$HOME&lt;/code> in a matter of seconds!
Let me demonstrate it for you with a LXD container,&lt;/p>
&lt;pre>&lt;code class="language-bash">$ lxc launch ubuntu:20.04 tmp-20-04
$ lxc profile add castle tmp-20-04
$ lxc ubuntu tmp-20-04
&lt;/code>&lt;/pre>
&lt;p>Ahhh, what a cozy tiny disposable home!&lt;/p>
&lt;p>That seemed to easy to you? Alright I confess, I used some of my own aliases here.
But isn&amp;rsquo;t it what this whole post is about?
Note that the above 3 lines really boils down to,&lt;/p>
&lt;pre>&lt;code class="language-bash">$ lxc launch ubuntu:20.04 tmp-20-04
$ lxc exec tmp-20-04 -- sudo --login --user ubuntu
...
$ git clone https://github.com/andsens/homeshick.git $HOME/.homesick/repos/homeshick
$ source ~/.homesick/repos/homeshick/homeshick.sh
$ homeshick clone git@github.com:user/dotfiles.git
$ homeshick link dotfiles
&lt;/code>&lt;/pre>
&lt;p>With this example,
I hope that I managed to offer you a glimpse at the power of &lt;code>homeshick&lt;/code>
(and more generally of dotfiles managers),
especially when coupled to a containerized workflow.&lt;/p>
&lt;p>Before closing this post, let me give you one last tip.
Because we made our containerized workflow rather seamless with our
host, it can be easy to loose track of which shell is in a container and which
is not. To differentiate them, add the following to your &lt;code>.bashrc&lt;/code>:&lt;/p>
&lt;pre>&lt;code class="language-bash">function prompt_lxc_header()
{
if [ -e /dev/lxd/sock ]; then
echo &amp;quot;[LXC] &amp;quot;;
fi
}
PS1='$(prompt_lxc_header)'$PS1
&lt;/code>&lt;/pre>
&lt;p>When used in a container,
a shell prompt in the said container will now look something like:&lt;/p>
&lt;pre>&lt;code class="language-bash">[LXC] ubuntu@tmp-20-04:~$
&lt;/code>&lt;/pre>
&lt;p>No more confusion 👍&lt;/p></description></item><item><title>My website</title><link>https://artivis.github.io/post/2020/my-website/</link><pubDate>Sat, 09 May 2020 00:00:00 +0000</pubDate><guid>https://artivis.github.io/post/2020/my-website/</guid><description>&lt;p>Here we are, looking for online visibility.
How does one set that up quickly when starting from scratch?
Do &lt;strong>you&lt;/strong> Remember those HTML courses?&lt;br>
&lt;strong>Yeah me neither.&lt;/strong>&lt;br>
But fortunately for us it is now easier than ever!&lt;/p>
&lt;p>We will discuss in this post how to create our own website with the
&lt;a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo&lt;/a> framework from a template and
how to deploy it to
&lt;a href="https://github.com/" target="_blank" rel="noopener">GitHub&lt;/a>.
The prerequisites are,&lt;/p>
&lt;ul>
&lt;li>GitHub&lt;/li>
&lt;li>markdown&lt;/li>
&lt;li>
&lt;a href="https://linuxcontainers.org/lxd/introduction/" target="_blank" rel="noopener">LXD&lt;/a> (optional)&lt;/li>
&lt;/ul>
&lt;p>You may find &lt;code>GitHub&lt;/code> tutorials
&lt;a href="https://guides.github.com/activities/hello-world/" target="_blank" rel="noopener">here&lt;/a>
and
&lt;a href="https://opensource.com/article/18/1/step-step-guide-git" target="_blank" rel="noopener">there&lt;/a>.
Pages of our website will be written in
&lt;a href="https://en.wikipedia.org/wiki/Markdown" target="_blank" rel="noopener">markdown&lt;/a>.
You can learn more about markdown from those tutorials,
&lt;a href="http://markdowntutorial.com/" target="_blank" rel="noopener">in English&lt;/a> and
&lt;a href="https://openclassrooms.com/courses/redigez-en-markdown" target="_blank" rel="noopener">in French&lt;/a>.
And if you only need a brief refresh,
&lt;a href="https://sourcethemes.com/academic/docs/writing-markdown-latex/" target="_blank" rel="noopener">here&lt;/a> is the syntax supported by our website.
Finally, you can find a &lt;code>LXD&lt;/code> tutorial
&lt;a href="https://linuxcontainers.org/lxd/getting-started-cli/" target="_blank" rel="noopener">here&lt;/a>.&lt;/p>
&lt;p>Now, let us set up the necessary stuff to get started, shall we?&lt;/p>
&lt;h1 id="picking-a-website-template">Picking a website template&lt;/h1>
&lt;p>To build our website, we will use the framework
&lt;a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo&lt;/a>.
It is very convenient for our use case because it comes with a ton of
&lt;a href="https://themes.gohugo.io/" target="_blank" rel="noopener">predefined website themes&lt;/a>
and it is very simple to use.&lt;/p>
&lt;p>For the purpose of this tutorial we will use the very theme of this website,
namely,
&lt;a href="https://themes.gohugo.io/academic/" target="_blank" rel="noopener">Academic&lt;/a>.
This theme is rather clean, well organized, fairly simple to use and most importantly
it is
&lt;a href="https://sourcethemes.com/academic/docs/" target="_blank" rel="noopener">well documented&lt;/a>!
Furthermore, it can be found pre-bundled in a &lt;code>Hugo&lt;/code> project so that
it is pretty much clone and play.
However, at the time of writing, this theme requires &lt;code>Hugo *Extended*&lt;/code> version 0.67+.
This distinction is important because,
while it is conveniently
&lt;a href="https://snapcraft.io/hugo" target="_blank" rel="noopener">packaged as a snap&lt;/a>,
the snap only offers the classic version, not the &lt;em>Extended&lt;/em>.
Therefore we have to fetch its debian package and install it manually.&lt;/p>
&lt;p>First, let us clone the ready-to-go &lt;code>Academic&lt;/code> bundle on our machine:&lt;/p>
&lt;pre>&lt;code class="language-bash">cd ~/
git clone https://github.com/sourcethemes/academic-kickstart.git my_website
cd my_website
git submodule update --init --recursive
&lt;/code>&lt;/pre>
&lt;h1 id="prepping-the-tools">Prepping the tools&lt;/h1>
&lt;p>To avoid polluting our system, we will set up a Linux container in which we will
install &lt;code>Hugo Extended&lt;/code>.
The container is totally optional and you can do the installation directly on your machine.
If you do not wish to use a container, skip directly to
&lt;a href="#installing-hugo">Hugo installation&lt;/a>&lt;/p>
&lt;h2 id="setting-up-the-lxc">Setting up the LXC&lt;/h2>
&lt;p>Let us start a fresh and pull a new &lt;code>Ubuntu 18.04&lt;/code> instance,&lt;/p>
&lt;pre>&lt;code class="language-bash">lxc launch ubuntu:18.04 hugo
&lt;/code>&lt;/pre>
&lt;p>We will now mount a disk device to share the website source code between our machine and the container:&lt;/p>
&lt;pre>&lt;code class="language-bash">lxc config device add hugo workspace disk source=~/my_website path=/home/ubuntu/my_website
lxc config set hugo raw.idmap &amp;quot;both $(id -u) $(id -g)&amp;quot;
lxc restart hugo
&lt;/code>&lt;/pre>
&lt;p>The default installation of &lt;code>LXD&lt;/code> set up a bridged network so that containers
live behind a NAT on the host. Therefore, we have to forward the port on which
our website is served by the &lt;code>Hugo&lt;/code> framework.
To do so, issue the following command:&lt;/p>
&lt;pre>&lt;code class="language-bash">lxc config device add hugo proxy1313 proxy connect=tcp:127.0.0.1:1313 listen=tcp:0.0.0.0:1313
&lt;/code>&lt;/pre>
&lt;p>The container is all set up. We can log to it with:&lt;/p>
&lt;pre>&lt;code class="language-bash">lxc exec hugo -- su --login ubuntu
&lt;/code>&lt;/pre>
&lt;h2 id="installing-hugo">Installing Hugo&lt;/h2>
&lt;p>We will download the &lt;code>Hugo&lt;/code> extended debian directly from it &lt;code>GitHub&lt;/code> repository.
To do so, enter in the terminal:&lt;/p>
&lt;pre>&lt;code class="language-bash">wget https://github.com/gohugoio/hugo/releases/download/v0.70.0/hugo_extended_0.70.0_Linux-64bit.deb
&lt;/code>&lt;/pre>
&lt;p>At the time of writing, the latest &lt;code>Hugo Extended&lt;/code> release is version 0.70.0.&lt;/p>
&lt;p>We can now install it with:&lt;/p>
&lt;pre>&lt;code class="language-bash">sudo dpkg -i hugo_extended_*.deb
&lt;/code>&lt;/pre>
&lt;h2 id="first-view-of-our-website">First view of our website&lt;/h2>
&lt;p>Let the show begin. We are now ready to spawn our website and browse it.
In a terminal, enter:&lt;/p>
&lt;pre>&lt;code class="language-bash">cd ~/my_website
hugo server
&lt;/code>&lt;/pre>
&lt;p>Voila!&lt;/p>
&lt;p>The website it up and running! To visualize it,
open your web browser at the address &lt;code>http://localhost:1313&lt;/code>.
That was easy right?&lt;/p>
&lt;h1 id="making-the-website-your-own">Making the website your own&lt;/h1>
&lt;p>We have a great template up and running, it is now time to make it our own.
The &lt;code>Academic&lt;/code> theme comes with a ton of options and configurations allowing us
to truly personalize it to our liking and use case.
And since its online documentation is so great,
I will let you discovers by yourself all the possibilities the theme offers.
Head down to the
&lt;a href="https://sourcethemes.com/academic/docs/get-started/" target="_blank" rel="noopener">Academic get started documentation&lt;/a>
and have fun!&lt;/p>
&lt;p>Just a quick advice, as you edit your website, let &lt;code>Hugo&lt;/code> run.
It is able to update the website live so that you see your changes take effect
immediately in your web browser!&lt;/p>
&lt;h1 id="deploying-the-website-to-github">Deploying the website to GitHub&lt;/h1>
&lt;p>Once our website is ready to be made public,
all there is to do is to push it to &lt;code>GitHub&lt;/code>.
Well, almost.&lt;/p>
&lt;p>In your &lt;code>GitHub&lt;/code> account, we will create a repository to host your website.
To do so hit the tiny cross &lt;code>(+)&lt;/code> in the top-right of &lt;code>GitHub&lt;/code> and select &lt;code>new repository&lt;/code>.
For &lt;code>GitHub&lt;/code> to be able to figure out that this particular repository is your personal website
we need to give it a specific name in the form : &lt;strong>&amp;lt;your-github-user-name&amp;gt;.github.io&lt;/strong>.&lt;/p>
&lt;p>We will now prepare to push the website to this repository.&lt;/p>
&lt;p>First we will add the &lt;code>GitHub&lt;/code> repository we just created as our remote,&lt;/p>
&lt;pre>&lt;code class="language-bash">git add remote origin https://github.com/&amp;lt;your-github-user-name&amp;gt;/&amp;lt;your-github-user-name&amp;gt;.github.io.git
&lt;/code>&lt;/pre>
&lt;p>and change our branch name to avoid later mess,&lt;/p>
&lt;pre>&lt;code class="language-bash">git branch -m master builder
&lt;/code>&lt;/pre>
&lt;p>Here comes the final step before pushing to &lt;code>GitHub&lt;/code>.
We must &lt;em>build&lt;/em> our website, or rather let &lt;code>Hugo&lt;/code> do it for us.
Indeed so far we have edited the template that &lt;code>Hugo&lt;/code> uses to build the website.
We have visualized it in our browser but the template cannot be deployed directly
to &lt;code>GitHub&lt;/code>, it must be built. To build it locally, nothing easier, simply run:&lt;/p>
&lt;pre>&lt;code class="language-bash">hugo
&lt;/code>&lt;/pre>
&lt;p>You will notice a new folder named &lt;code>public&lt;/code> in our project.
It contains the generated website. It is this content that we must push to our repository.
Furthermore, it must be pushed specifically to the &lt;code>master&lt;/code> branch.
That&amp;rsquo;s a limitation of personal website on &lt;code>GitHub&lt;/code>.&lt;/p>
&lt;h2 id="automatic-deployment">Automatic deployment&lt;/h2>
&lt;p>So how could we automatize this build and deploy process?&lt;/p>
&lt;p>We will add a small script so that every times
we push some new content on the &lt;code>builder&lt;/code> branch,
&lt;code>GitHub&lt;/code> will take care of calling &lt;code>Hugo&lt;/code> (building) and
moving the &lt;code>public&lt;/code> folder directly on the &lt;code>master&lt;/code> branch (deploying).&lt;/p>
&lt;p>For that, we will use &lt;code>GitHub actions&lt;/code> and more specifically the
&lt;a href="https://github.com/peaceiris/actions-hugo" target="_blank" rel="noopener">&lt;code>actions-hugo&lt;/code>&lt;/a>.
Sorry buddy but I&amp;rsquo;ll skip the details about &lt;code>actons&lt;/code> here as it is all new
to me as well. That could be the topic for a later post tho.&lt;/p>
&lt;p>We will simply create a new file in our project to configure the action:&lt;/p>
&lt;pre>&lt;code class="language-bash">cd ~/my_website
touch .github/workflows/deploy-website.yml
&lt;/code>&lt;/pre>
&lt;p>which we will edit as follows:&lt;/p>
&lt;pre>&lt;code class="language-yaml">name: deploy website
# We will run the actions whenever something
# is pushed to the branch 'builder'
on:
push:
branches:
- builder
jobs:
# Our action is called 'deploy' and runs on Ubuntu 18.04
deploy:
runs-on: ubuntu-18.04
# The action executes the following steps
steps:
# It fetch our repository and its submodules
- uses: actions/checkout@v2
with:
submodules: true # Fetch Hugo themes
fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod
# It then set up Hugo Extended
- name: Setup Hugo
uses: peaceiris/actions-hugo@v2
with:
hugo-version: '0.68.3'
extended: true
# It runs Hugo to generate the website
- name: Build
run: hugo --minify
# It copies the content of the 'public' folder to the branch 'master'
- name: Deploy
uses: peaceiris/actions-gh-pages@v3
with:
github_token: ${{ secrets.GITHUB_TOKEN }}
publish_dir: ./public
publish_branch: master
&lt;/code>&lt;/pre>
&lt;p>With our automatic deployment configured, all there remains to do is to push to &lt;code>GitHub&lt;/code>!&lt;/p>
&lt;p>Let us remove the &amp;lsquo;public&amp;rsquo; folder is it exists,&lt;/p>
&lt;pre>&lt;code class="language-bash">cd ~/my_website
rm -r public
&lt;/code>&lt;/pre>
&lt;p>and commit all of our changes,&lt;/p>
&lt;pre>&lt;code class="language-bash">git add .
git commit 'made the website my own'
&lt;/code>&lt;/pre>
&lt;p>Finally, we push the changes upstream,&lt;/p>
&lt;pre>&lt;code class="language-bash">git push origin builder
&lt;/code>&lt;/pre>
&lt;p>Voila!&lt;/p>
&lt;p>After a couple minutes your website is now available at the address:&lt;/p>
&lt;p>&lt;code>https://&amp;lt;your-github-user-name&amp;gt;.github.io/&lt;/code>&lt;/p>
&lt;p>Congrats on your new online visibility, our job here is done.&lt;/p>
&lt;h1 id="bonus-academic-publications">Bonus: Academic publications&lt;/h1>
&lt;p>If you happen to have some academic publications that you would like to showcase
on your website, we will install a Python tool called &lt;code>academic&lt;/code>
that will help us to automatically generate pages from &lt;code>Bibtex&lt;/code>.&lt;/p>
&lt;p>First we will install &lt;code>pip3&lt;/code>:&lt;/p>
&lt;pre>&lt;code class="language-bash">apt install python3-pip
&lt;/code>&lt;/pre>
&lt;p>to then install &lt;code>academic&lt;/code>:&lt;/p>
&lt;pre>&lt;code class="language-bash">pip3 install -U academic
&lt;/code>&lt;/pre>
&lt;p>Given that we have a &lt;code>.bib&lt;/code> file that contains all of our publications,
we can generate the pages as follows:&lt;/p>
&lt;pre>&lt;code class="language-bash">cd ~/my_website
academic import --bibtex &amp;lt;path_to_your/publications.bib&amp;gt;
&lt;/code>&lt;/pre>
&lt;p>You can find more information in the
&lt;a href="https://sourcethemes.com/academic/docs/managing-content/#create-a-publication" target="_blank" rel="noopener">Academic theme documentation&lt;/a>.&lt;/p></description></item><item><title>ROS Noetic development workflow in LXC</title><link>https://artivis.github.io/post/2020/lxc/</link><pubDate>Sat, 09 May 2020 00:00:00 +0000</pubDate><guid>https://artivis.github.io/post/2020/lxc/</guid><description>&lt;p>In this post, we will discuss how to setup a
&lt;a href="https://linuxcontainers.org/" target="_blank" rel="noopener">Linux container&lt;/a>
- a.k.a
&lt;a href="https://linuxcontainers.org/" target="_blank" rel="noopener">LXC&lt;/a> - for our
&lt;a href="http://wiki.ros.org/noetic" target="_blank" rel="noopener">ROS Noetic&lt;/a> development.
Developing in containers has several
advantages such as:&lt;/p>
&lt;ul>
&lt;li>allowing us to use a different Linux distribution than the one we&amp;rsquo;ve installed on
our host machine&lt;/li>
&lt;li>providing a repeatable course of actions&lt;/li>
&lt;li>messing around, installing a tons of dependencies without polluting our computer&lt;/li>
&lt;li>burning the container to the ground and starting fresh again easily&lt;/li>
&lt;/ul>
&lt;p>There are of course many other upsides but those are the one we are really
interested in for now.
We will see first how to get started with LXC and install the latest ROS release Noetic.
We will then configure our container so that it is able to share a workspace
with our host machine. We will also enable the use of graphical applications
from the container (e.g. Rviz, Gazebo).&lt;/p>
&lt;p>The main prerequisites for this post are to be familiar with:&lt;/p>
&lt;ul>
&lt;li>the command terminal in Linux&lt;/li>
&lt;li>ROS development&lt;/li>
&lt;li>LXC&lt;/li>
&lt;/ul>
&lt;p>Note that I will be linking resources throughout the text,
make sure to check them whenever you need further information.&lt;/p>
&lt;p>Finally, while we will be focusing on the latest ROS Noetic release,
the setup presented here applies not only to other ROS distributions
but likely to most projects, be them ROS-based or not.&lt;/p>
&lt;hr>
&lt;h1 id="content">Content&lt;/h1>
&lt;ul>
&lt;li>
&lt;a href="#setting-up-the-lxc">Setting up the LXC&lt;/a>
&lt;ul>
&lt;li>
&lt;a href="#lxc-aliases-to-the-rescue">LXC aliases to the rescue&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;a href="#install-ros-noetic">Install ROS Noetic&lt;/a>&lt;/li>
&lt;li>
&lt;a href="#mounting-a-local-workspace">Mounting a local workspace&lt;/a>&lt;/li>
&lt;li>
&lt;a href="#using-graphical-applications">Using graphical applications&lt;/a>
&lt;ul>
&lt;li>
&lt;a href="#creating-a-lxd-profile">Creating a LXD profile&lt;/a>&lt;/li>
&lt;li>
&lt;a href="#dedicated-graphic-card">Dedicated graphic card&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;a href="#profile-all-the-things">Profile all the things!&lt;/a>&lt;/li>
&lt;li>
&lt;a href="#wrapping-up">Wrapping up&lt;/a>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h1 id="setting-up-the-lxc">Setting up the LXC&lt;/h1>
&lt;p>We will start by installing LXD, a lightweight container hypervisor which
extends LXC functionality over the network.
LXD uses LXC under the covers for some container management tasks and
provides the &amp;lsquo;lxc&amp;rsquo; command line interface tool we will use throughout this post.
For more information, you can refer to the
&lt;a href="https://ubuntu.com/server/docs/containers-lxc" target="_blank" rel="noopener">LXC&lt;/a> and
&lt;a href="https://ubuntu.com/server/docs/containers-lxd" target="_blank" rel="noopener">LXD&lt;/a> documentation
on the Ubuntu website.&lt;/p>
&lt;p>Alright, let us install LXD as a
&lt;a href="https://snapcraft.io/" target="_blank" rel="noopener">snap&lt;/a> to make sure we always run
the most up to date stable version:&lt;/p>
&lt;pre>&lt;code class="language-bash">$ sudo snap install lxd
&lt;/code>&lt;/pre>
&lt;p>Before we can create our first container, we must initialize LXD,&lt;/p>
&lt;pre>&lt;code class="language-bash">$ sudo lxd init
&lt;/code>&lt;/pre>
&lt;p>This command will prompt you with a bunch of questions to fine tune LXD use.
Unless you know what you are doing, you can safely hit the default answers.&lt;/p>
&lt;p>Finally, we will add our user to the &amp;lsquo;lxd&amp;rsquo; group so that we can run lxd commands
without sudo,&lt;/p>
&lt;pre>&lt;code class="language-bash">$ sudo gpasswd -a &amp;quot;${USER}&amp;quot; lxd
&lt;/code>&lt;/pre>
&lt;p>You should log out and log in again for this to take effect.&lt;/p>
&lt;h2 id="creating-the-container">Creating the container&lt;/h2>
&lt;p>To create a new container, we will use the following command,&lt;/p>
&lt;pre>&lt;code class="language-bash">$ lxc launch {remote}:{image} {container-name}
&lt;/code>&lt;/pre>
&lt;p>Since Noetic runs on Ubuntu 20.04, we will fetch a Ubuntu 20.04 image
from the official Ubuntu remote,&lt;/p>
&lt;pre>&lt;code class="language-bash">$ lxc launch ubuntu:20.04 ros-noetic
&lt;/code>&lt;/pre>
&lt;p>We can check that the container was properly created and launched,&lt;/p>
&lt;pre>&lt;code class="language-bash">$ lxc list
+---------------+---------+-----------------------+-----------------------------------------------+-----------+-----------+
| NAME | STATE | IPV4 | IPV6 | TYPE | SNAPSHOTS |
+---------------+---------+-----------------------+-----------------------------------------------+-----------+-----------+
| ros-noetic | RUNNING | 10.160.218.172 (eth0) | dd42:5ke1:fr68:2ca4:236:eff3:fe3r:7c21 (eth0) | CONTAINER | 0 |
+---------------+---------+-----------------------+-----------------------------------------------+-----------+-----------+
&lt;/code>&lt;/pre>
&lt;p>With our container up and running, we can open a shell in it with a non-root user
with the following command,&lt;/p>
&lt;pre>&lt;code class="language-bash">$ lxc exec ros-noetic -- sudo --login --user ubuntu
&lt;/code>&lt;/pre>
&lt;p>I know, this command is not very pretty nor easy to remember.
But worry not, we will create an alias to ease future use.&lt;/p>
&lt;h2 id="lxc-aliases-to-the-rescue">LXC aliases to the rescue&lt;/h2>
&lt;p>LXC aliases, just like bash aliases, allow use to create a new CLI
keywords to which we can associate an action.
The command to create a new alias is,&lt;/p>
&lt;pre>&lt;code class="language-bash">$ lxc alias add {alias} '{command}'
&lt;/code>&lt;/pre>
&lt;p>As an example, let us create a shorter version of the &lt;code>lxc list&lt;/code> command
that also prints a more compact result:&lt;/p>
&lt;pre>&lt;code class="language-bash">$ lxc alias add ls 'list --format csv -c n'
&lt;/code>&lt;/pre>
&lt;p>We can check that the alias is correctly created,&lt;/p>
&lt;pre>&lt;code class="language-bash">$ lxc alias list
+--------+----------------------------------------------------------------------------------+
| ALIAS | TARGET |
+--------+----------------------------------------------------------------------------------+
| ls | list --format csv -c n |
+--------+----------------------------------------------------------------------------------+
&lt;/code>&lt;/pre>
&lt;p>And we can now simply use it,&lt;/p>
&lt;pre>&lt;code class="language-bash">$ lxc ls
ros-noetic
&lt;/code>&lt;/pre>
&lt;p>That&amp;rsquo;s pretty neat.&lt;/p>
&lt;p>But our main goal with aliases was to simplify our shell
login to the container, so let&amp;rsquo;s just do that.
Borrowing from the excellent
&lt;a href="https://blog.simos.info/using-command-aliases-in-lxd-to-exec-a-shell/" target="_blank" rel="noopener">blog post by Simos Xenitellis&lt;/a>
about LXC aliases, we will create a new alias &amp;lsquo;ubuntu&amp;rsquo; such as,&lt;/p>
&lt;pre>&lt;code class="language-bash">$ lxc alias add ubuntu 'exec @ARGS@ --mode interactive -- /bin/sh -xac $@ubuntu - exec /bin/login -p -f '
&lt;/code>&lt;/pre>
&lt;p>This alias allows us now to simply connect to our container with,&lt;/p>
&lt;pre>&lt;code class="language-bash">$ lxc ubuntu ros-noetic
&lt;/code>&lt;/pre>
&lt;p>That&amp;rsquo;s much better isn&amp;rsquo;t it?&lt;/p>
&lt;h1 id="install-ros-noetic">Install ROS Noetic&lt;/h1>
&lt;p>
&lt;a href="http://wiki.ros.org/noetic" target="_blank" rel="noopener">ROS Noetic&lt;/a> is the latest and final ROS 1 release.
The ROS project hasn&amp;rsquo;t come to an end, on the contrary, it rather look forward
and focus its efforts
toward the second version, namely ROS 2.
Nevertheless, ROS Noetic is an important release because it targets
Ubuntu 20.04, has official Python 3 support and will be supported until
May 2025 (more information on
&lt;a href="http://wiki.ros.org/noetic" target="_blank" rel="noopener">Noetic wiki page&lt;/a>).
That leaves us plenty of time to learn and move to ROS 2.&lt;/p>
&lt;p>To install it, let&amp;rsquo;s first connect to our container using our new LXC alias,&lt;/p>
&lt;!-- we will simply follow the [official documentation][noetic-install]. -->
&lt;!-- Let us execute a shell in our container using our new LXC alias, -->
&lt;pre>&lt;code class="language-bash">$ lxc ubuntu ros-noetic
&lt;/code>&lt;/pre>
&lt;p>First, we will add the ROS packages repository to our sources.
Starting with the key,&lt;/p>
&lt;pre>&lt;code class="language-bash">$ apt-key adv --fetch-keys https://raw.githubusercontent.com/ros/rosdistro/master/ros.asc
&lt;/code>&lt;/pre>
&lt;p>then the repository,&lt;/p>
&lt;pre>&lt;code class="language-bash">$ apt-add-repository http://packages.ros.org/ros/ubuntu
&lt;/code>&lt;/pre>
&lt;p>In case of trouble, you can also refer to the
&lt;a href="http://wiki.ros.org/noetic/Installation/Ubuntu" target="_blank" rel="noopener">official documentation&lt;/a>.&lt;/p>
&lt;p>We are all set to install ROS Noetic!&lt;/p>
&lt;p>Here we can choose either of three installations;
we can install only the core components,&lt;/p>
&lt;pre>&lt;code class="language-bash">$ sudo apt install ros-noetic-ros-base
&lt;/code>&lt;/pre>
&lt;p>or core + the visualization stack (e.g. Rviz),&lt;/p>
&lt;pre>&lt;code class="language-bash">$ sudo apt install ros-noetic-desktop
&lt;/code>&lt;/pre>
&lt;p>or core + the visualization + simulation stacks (e.g. Gazebo),&lt;/p>
&lt;pre>&lt;code class="language-bash">$ sudo apt install ros-noetic-desktop-full
&lt;/code>&lt;/pre>
&lt;p>You can pick any depending on your needs.
If you are not sure, I would recommend you install only the core components
and later install other packages on a per-need basis:&lt;/p>
&lt;pre>&lt;code class="language-bash">$ sudo apt install ros-noetic-ros-base
...
$ sudo apt install ros-noetic-&amp;lt;package-I-need&amp;gt;
&lt;/code>&lt;/pre>
&lt;p>Simply to keep the size of the container as small as possible.&lt;/p>
&lt;p>Finally, we will automatically source Noetic since this container is dedicated
to it,&lt;/p>
&lt;pre>&lt;code class="language-bash">$ echo &amp;quot;source /opt/ros/noetic/setup.bash&amp;quot; &amp;gt;&amp;gt; ~/.bashrc
&lt;/code>&lt;/pre>
&lt;p>Every times we will log into our container, ROS Noetic will be sourced
and we will be ready to develop!&lt;/p>
&lt;h1 id="mounting-a-local-workspace">Mounting a local workspace&lt;/h1>
&lt;p>What would our development workflow look like without some actual source code to
work on? Well, let us set up our ROS workspace.&lt;/p>
&lt;p>Rather than copying/creating our workspace in the container,
we will keep it on the host machine. By doing so,
not only the workspace will survive deleting the LXC (persistence)
but we will also be able to share it across several LXC
thus across several ROS distros.&lt;/p>
&lt;p>Hereafter, we will assume our workspace to be simply &lt;code>~/workspace&lt;/code>
on the host with the classic tree,&lt;/p>
&lt;pre>&lt;code class="language-bash">$ tree ~/workspace
/home/user/workspace/
└── src
└── my_ros_package
└...
&lt;/code>&lt;/pre>
&lt;p>To share a folder with the container, we have to add a &amp;lsquo;device disk&amp;rsquo; to it.
The general command to do so is of the form,&lt;/p>
&lt;pre>&lt;code class="language-bash">$ lxc config device add {container} {device-name} disk source={full-path-to-folder} path={full-path-inside-container}
&lt;/code>&lt;/pre>
&lt;p>filling up the placeholders for our use case, it reads,&lt;/p>
&lt;pre>&lt;code class="language-bash">$ lxc config device add ros-noetic workspace disk source=~/workspace path=/home/ubuntu/workspace
&lt;/code>&lt;/pre>
&lt;p>Once the device added, we have to configure the access rights so that we can read and write
the folder and its content in the container,&lt;/p>
&lt;pre>&lt;code class="language-bash">$ lxc config set ros-noetic raw.idmap &amp;quot;both $(id -u) $(id -g)&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>We now have to restart the container for the changes to take effects,&lt;/p>
&lt;pre>&lt;code class="language-bash">$ lxc restart ros-noetic
&lt;/code>&lt;/pre>
&lt;p>Let us log back into our container,&lt;/p>
&lt;pre>&lt;code class="language-bash">$ lxc ubuntu ros-noetic
&lt;/code>&lt;/pre>
&lt;p>and verify that the folder is properly mounted,&lt;/p>
&lt;pre>&lt;code class="language-bash">$ ls -l
drwxr-xr-x 22 ubuntu ubuntu 4096 May 22 21:21 workspace
&lt;/code>&lt;/pre>
&lt;p>Looks like we are good!&lt;/p>
&lt;p>In this section we have configured our container through the &lt;code>lxc config&lt;/code>
cli tool. Note that container configuration is saved in a yaml file, which you
can review with,&lt;/p>
&lt;pre>&lt;code class="language-bash">$ lxc config show {container}
&lt;/code>&lt;/pre>
&lt;p>and directly edit with,&lt;/p>
&lt;pre>&lt;code class="language-bash">$ lxc config edit {container}
&lt;/code>&lt;/pre>
&lt;p>More on that later.&lt;/p>
&lt;h1 id="using-graphical-applications">Using graphical applications&lt;/h1>
&lt;p>This part is totally &lt;em>optional&lt;/em> and depends on whether you are planning to run
some graphical applications (e.g. Rviz, Gazebo) in your container or not.
If you are not interested in running any gui in your container,
you may still want to have a quick look before jumping at the
&amp;lsquo;
&lt;a href="#profile-all-the-things">Profile all the things!&lt;/a>&amp;rsquo; section.
If you do want to run graphical applications,
then we have to configure the container to support that.&lt;/p>
&lt;p>Unlike in the previous section, we are not going to use the &lt;code>lxc config&lt;/code> tool
to configure our container. Instead, we will introduce &lt;code>lxc profile&lt;/code> as a way
to create easily reusable configurations.A &lt;em>profile&lt;/em> is a set of parameters
that can be applied to a container in one go. It can describe a full fledged
setup or a particular feature as in our case below.
Furthermore a profile can be use by a single container or many. Reusability!&lt;/p>
&lt;h2 id="creating-a-lxd-profile">Creating a LXD profile&lt;/h2>
&lt;p>Let us first create a profile named &lt;code>gui&lt;/code>,&lt;/p>
&lt;pre>&lt;code class="language-bash">$ lxc profile create gui
&lt;/code>&lt;/pre>
&lt;p>we can now edit the profile,&lt;/p>
&lt;pre>&lt;code class="language-bash">$ lxc profile edit gui
&lt;/code>&lt;/pre>
&lt;p>and paste the following,&lt;/p>
&lt;pre>&lt;code class="language-yaml">config:
environment.DISPLAY: :0
raw.idmap: both 1000 1000
description: Enables graphical apps use.
devices:
X0:
path: /tmp/.X11-unix/X0
source: /tmp/.X11-unix/X0
type: disk
mygpu:
type: gpu
name: gui
used_by: []
&lt;/code>&lt;/pre>
&lt;p>Alternatively, you can use the following one liner,&lt;/p>
&lt;pre>&lt;code class="language-bash">curl https://gist.githubusercontent.com/artivis/37c961e157e99f6fcaff0204a0f59731/raw/ca4abd1a3c6b1d8a74910207903ac7723685dce1/gui.yaml | lxc profile edit gui
&lt;/code>&lt;/pre>
&lt;p>In this profile, there might be a couple things for you to tweak depending on
your machine. For instance your user id and guid,&lt;/p>
&lt;pre>&lt;code class="language-bash">raw.idmap: both 1000 1000
&lt;/code>&lt;/pre>
&lt;p>which you can retrieve respectively with:&lt;/p>
&lt;pre>&lt;code class="language-bash">$ id -u
1000
$ id -g
1000
&lt;/code>&lt;/pre>
&lt;p>You may also have to check your graphic card in use looking at the directory
&lt;code>/tmp/.X11-unix/&lt;/code>.&lt;/p>
&lt;p>Now that our profile is set up, we have to add it to our container,&lt;/p>
&lt;pre>&lt;code class="language-bash">lxc profile add ros-noetic gui
&lt;/code>&lt;/pre>
&lt;p>As previously, we have to restart the container for those change to take effect,&lt;/p>
&lt;pre>&lt;code class="language-bash">lxc restart ros-noetic
&lt;/code>&lt;/pre>
&lt;p>Alright, let us try to open Rviz to make sure everything went fine.
Open two shells to the container, one running the roscore and the second
running Rviz:&lt;/p>
&lt;p>Shell 1&lt;/p>
&lt;pre>&lt;code class="language-bash">$ roscore
&lt;/code>&lt;/pre>
&lt;p>Shell 2&lt;/p>
&lt;pre>&lt;code class="language-bash">$ rosrun rviz rviz
&lt;/code>&lt;/pre>
&lt;p>We are getting really close to our regular development experience aren&amp;rsquo;t we?&lt;/p>
&lt;h2 id="dedicated-graphic-card">Dedicated graphic card&lt;/h2>
&lt;p>If you have a dedicated graphic card on your host machine,
you will also have to install the &lt;em>very same driver&lt;/em> in the container
in order to use graphical applications.
If you have an Nvidia card, the following should help you.
To figure out the driver version on the host we&amp;rsquo;ll type,&lt;/p>
&lt;pre>&lt;code class="language-bash">$ nvidia-smi
Mon May 12 11:59:59 2020
+-----------------------------------------------------------------------------+
| NVIDIA-SMI 440.82 Driver Version: 440.82 CUDA Version: 10.2 |
+-------------------------------+----------------------+----------------------+
&lt;/code>&lt;/pre>
&lt;p>All we have to do now is to install the same driver in the container,&lt;/p>
&lt;pre>&lt;code class="language-bash">$ sudo apt install nvidia-440
&lt;/code>&lt;/pre>
&lt;h1 id="profile-all-the-things">Profile all the things&lt;/h1>
&lt;p>We have seen in section
&lt;a href="#creating-a-lxd-profile">&amp;lsquo;Creating a LXD profile&amp;rsquo;&lt;/a> how to
create a LXC profile to easily support running graphical
apps in our container(s).
As we mentioned before, a profile really only is a set of configurations
for our container.
So one may ask&lt;/p>
&lt;blockquote>
&lt;p>can&amp;rsquo;t we create some other profiles to further group all the configs we&amp;rsquo;ve seen?&lt;/p>
&lt;/blockquote>
&lt;p>Well, yes we can! And guess what? Containers can have several profiles!
So we could totally create another profile to automatically
add the ROS apt repository, both for ROS 1 and ROS 2 respectively:&lt;/p>
&lt;pre>&lt;code class="language-bash">$ lxc profile create ros-apt
$ lxc profile edit ros-apt
&lt;/code>&lt;/pre>
&lt;p>and add,&lt;/p>
&lt;pre>&lt;code class="language-yaml">config:
user.user-data: |
#cloud-config
runcmd:
- &amp;quot;apt-key adv --fetch-keys https://raw.githubusercontent.com/ros/rosdistro/master/ros.asc&amp;quot;
- &amp;quot;apt-add-repository http://packages.ros.org/ros/ubuntu&amp;quot;
- &amp;quot;apt-add-repository http://packages.ros.org/ros2/ubuntu&amp;quot;
description: &amp;quot;Add ROS apt repository&amp;quot;
devices: {}
name: ros
used_by: {}
&lt;/code>&lt;/pre>
&lt;p>Similarly we could create another profile to easily share our ROS workspace
as well,&lt;/p>
&lt;pre>&lt;code class="language-bash">$ lxc profile create ros-ws
$ lxc profile edit ros-ws
&lt;/code>&lt;/pre>
&lt;p>and add,&lt;/p>
&lt;pre>&lt;code class="language-yaml">config:
raw.idmap: both 1000 1000
description: &amp;quot;Share the ROS workspace&amp;quot;
devices:
workspaces:
path: /home/ubuntu/workspace
source: /home/user/workspace
type: disk
name: ros-ws
used_by: {}
&lt;/code>&lt;/pre>
&lt;p>And remember to tweak both profiles (user id/guid etc.).&lt;/p>
&lt;p>Both profiles will greatly help when creating a new container.
However, before we get all excited, let me tell you that
we have to be cautious when using them.
The reason is that both should be added a rather specific times
of the container creation. Let us see when that is.&lt;/p>
&lt;p>First, the &amp;lsquo;ros-apt&amp;rsquo; profile makes use of
&lt;a href="https://cloudinit.readthedocs.io/en/latest/index.html" target="_blank" rel="noopener">cloud-init&lt;/a>
to preconfigure the container meaning that our &lt;code>apt-key/apt-add-repository&lt;/code>
command will be run &lt;strong>only once&lt;/strong> when the container is &lt;strong>first created&lt;/strong>
(see
&lt;a href="https://blog.simos.info/how-to-preconfigure-lxd-containers-with-cloud-init/" target="_blank" rel="noopener">this other blog post by Simos Xenitellis&lt;/a>
for more info about cloud-init in LXD).
To create a container with given profile(s),
the &lt;code>lxc launch&lt;/code> commands changes to,&lt;/p>
&lt;pre>&lt;code class="language-bash">$ lxc launch --profile {profile-a} --profile {profile-b} {remote}:{image} {container-name}
&lt;/code>&lt;/pre>
&lt;p>which in our case looks like,&lt;/p>
&lt;pre>&lt;code class="language-bash">$ lxc launch --profile default --profile ros-apt ubuntu:20.04 ros-noetic2
&lt;/code>&lt;/pre>
&lt;p>Let me insist again. If you try to &lt;em>add&lt;/em> the &amp;lsquo;ros-apt&amp;rsquo; profile after the container
was created, &lt;em>nothing will happen&lt;/em>:
&lt;del>&lt;code>lxd profile add ros-noetic ros-apt&lt;/code>&lt;/del>!&lt;/p>
&lt;p>Concerning our &amp;lsquo;ros-ws&amp;rsquo; profile, it is a bit of the opposite situation.
Indeed, when creating the container, a whole bunch of things are ran before
the &amp;lsquo;ubuntu&amp;rsquo; user is set up. Since we are linking our workspace to &lt;code>/home/ubuntu/&lt;/code>
we may arrive to early so to speak and it results in messing up the
proper set up of the user. For this profile, we therefore
&lt;em>have to add it after the container creation&lt;/em>
(&lt;del>&lt;code>lxc launch --profile ros-ws {remote}:{image} {container-name}&lt;/code>&lt;/del>).&lt;/p>
&lt;p>We can add our ros-ws profile to a container with,&lt;/p>
&lt;pre>&lt;code class="language-bash">$ lxc profile add ros-noetic ros-ws
&lt;/code>&lt;/pre>
&lt;p>This whole tempo story sounds annoying.
Alright let&amp;rsquo;s call it a day and summarize how to set up a new container.&lt;/p>
&lt;h1 id="wrapping-up">Wrapping up&lt;/h1>
&lt;p>Well, that was quite a journey in LXD realm.
But our efforts were not vain for we have learned a lot
about LXD and set up some great tools.&lt;/p>
&lt;p>Soon, the
&lt;a href="https://index.ros.org/doc/ros2/Releases/Release-Foxy-Fitzroy/" target="_blank" rel="noopener">ROS 2 Foxy&lt;/a> distro will be released
(5th of June).
How will we then create a Foxy container?
Well, that&amp;rsquo;s quite simple now:&lt;/p>
&lt;pre>&lt;code class="language-bash">$ lxc launch --profile default --profile ros-apt --profile gui ubuntu:20.04 ros-foxy
$ lxc profile add ros-foxy ros-ws
$ lxc ubuntu ros-foxy
...
$ sudo apt install ros-foxy-desktop
&lt;/code>&lt;/pre>
&lt;p>Off we go!&lt;/p>
&lt;!--
# Speed up new LXC set up
@todo: snapshots + create container from snapshots + lxc-this script. Maybe for another post?
-->
&lt;!-- Links --></description></item><item><title>SSH the Raspberry Pi Zero over USB</title><link>https://artivis.github.io/post/2020/pi-zero/</link><pubDate>Sat, 09 May 2020 00:00:00 +0000</pubDate><guid>https://artivis.github.io/post/2020/pi-zero/</guid><description>&lt;p>In this post, we will see how to SSH a Raspberry Pi Zero
over USB from a Ubuntu-based host.
Moreover we will make sure the the Pi Zero has access to internet through the host
so that we can install/update some software.&lt;/p>
&lt;h1 id="content">Content&lt;/h1>
&lt;ul>
&lt;li>
&lt;a href="#install-raspbian">Install Raspbian&lt;/a>&lt;/li>
&lt;li>
&lt;a href="#ssh-over-usb">SSH over USB&lt;/a>&lt;/li>
&lt;li>
&lt;a href="#set-usb-gadget-mode">Set USB Gadget mode&lt;/a>&lt;/li>
&lt;li>
&lt;a href="#set-the-connection-to-shared-with-other-computers">Set the connection to &amp;lsquo;Shared with other computers&amp;rsquo;&lt;/a>&lt;/li>
&lt;li>
&lt;a href="#set-a-static-mac-address">Set a static MAC address&lt;/a>&lt;/li>
&lt;li>
&lt;a href="#set-a-static-ip-address">Set a static IP address&lt;/a>&lt;/li>
&lt;/ul>
&lt;h1 id="install-raspbian">Install Raspbian&lt;/h1>
&lt;p>There exists plenty of tutorials on the topic of installing Raspbian
(see the the
&lt;a href="https://www.raspberrypi.org/documentation/installation/installing-images/" target="_blank" rel="noopener">official documentation&lt;/a>)
therefore I will not detail it here.
To summarize, you have to,&lt;/p>
&lt;ol>
&lt;li>Download
&lt;a href="https://www.raspberrypi.org/downloads/raspbian/" target="_blank" rel="noopener">&lt;code>Raspian&lt;/code>&lt;/a> (Lite for headless)&lt;/li>
&lt;li>Burn the image on a micro SD card with
&lt;a href="https://www.balena.io/etcher/" target="_blank" rel="noopener">&lt;code>Etcher&lt;/code>&lt;/a>&lt;/li>
&lt;/ol>
&lt;p>Before unplugging the card we will enable SSH connections.
To do so, open the &lt;code>boot&lt;/code> partition on the card and simply create
an empty &lt;code>ssh&lt;/code> file:&lt;/p>
&lt;pre>&lt;code class="language-bash">$ cd /path/to/root/
$ touch ssh
&lt;/code>&lt;/pre>
&lt;ol start="3">
&lt;li>Plug the card on the Pi Zero&lt;/li>
&lt;/ol>
&lt;h1 id="ssh-over-usb">SSH over USB&lt;/h1>
&lt;p>With the micro SD card ready we can now plug the USB cable to our host
and Pi Zero.
However, note that while the Pi Zero has two micro USB port,
only one supports USB On-The-Go (OTG). It is this feature that
will allows us to treat the connection as an Ethernet connection.
The port in question is the &lt;strong>innermost&lt;/strong> one,
the one closer to the center of the board, as shown in the image below.&lt;/p>
&lt;p>&lt;img src="https://artivis.github.io/img/post/pizero-usb-host.png" alt="Raspberry Pi Zero USB OTG port">&lt;/p>
&lt;h2 id="set-usb-gadget-mode">Set USB Gadget mode&lt;/h2>
&lt;p>We would like to be able to access the Pi Zero through SSH
from our machine using a USB cable.
To do that we will have to edit two files.&lt;/p>
&lt;p>First, edit the file &lt;code>/boot/config.txt&lt;/code> and append this line at the end:&lt;/p>
&lt;pre>&lt;code class="language-terminal">dtoverlay=dwc2
&lt;/code>&lt;/pre>
&lt;p>Second, we will edit the file &lt;code>/boot/cmdline.txt&lt;/code>.
After &lt;code>rootwait&lt;/code>, we will add&lt;/p>
&lt;pre>&lt;code class="language-terminal">modules-load=dwc2,g_ether
&lt;/code>&lt;/pre>
&lt;p>⚠ pay attention to leave only one space between &lt;code>rootwait&lt;/code>
and the new text otherwise it might not be parsed correctly.&lt;br>
⚠ Note that there might already be some text after &lt;code>rootwait&lt;/code>
in which case you still must add the following immediately after &lt;code>rootwait&lt;/code>!
Again, leave a single space after &lt;code>rootwait&lt;/code> but also after &lt;code>g_ether&lt;/code>.&lt;/p>
&lt;p>The Pi Zero is fully configured, we can now configure our host.&lt;/p>
&lt;h2 id="set-the-connection-to-shared-with-other-computers">Set the connection to Shared with other computers&lt;/h2>
&lt;p>On your Linux host, go to the network connections editor.
In the &amp;lsquo;&lt;em>IPv4 Settings&lt;/em>&amp;rsquo; tab,
set &amp;lsquo;&lt;em>Method&lt;/em>:&amp;rsquo; to &amp;lsquo;&lt;em>Shared with other computers&lt;/em>'.
Refresh the connection (dis/connect), after what
you should be able to SSH to the Pi Zero.&lt;/p>
&lt;p>To SSH to the Pi Zero, open a terminal on your host and type:&lt;/p>
&lt;pre>&lt;code class="language-terminal">$ ssh pi@rasberrypi.local
&lt;/code>&lt;/pre>
&lt;p>You will be prompted for a password, use the
&lt;a href="https://www.raspberrypi.org/documentation/linux/usage/users.md" target="_blank" rel="noopener">default one for user &amp;lsquo;pi&amp;rsquo;&lt;/a>.
And do not forget to change it down the line!&lt;/p>
&lt;p>We are now connected on our board, let&amp;rsquo;s try internet out.
Since we are using the method &amp;lsquo;&lt;em>Shared with other computers&lt;/em>&amp;rsquo;
we should be able to access internet:&lt;/p>
&lt;pre>&lt;code class="language-terminal">$ ping -c 3 www.google.com
PING www.google.com (172.217.13.100) 56(84) bytes of data.
64 bytes from yul02s04-in-f4.1e100.net (172.217.13.100): icmp_seq=1 ttl=57 time=10.7 ms
64 bytes from yul02s04-in-f4.1e100.net (172.217.13.100): icmp_seq=2 ttl=57 time=9.60 ms
64 bytes from yul02s04-in-f4.1e100.net (172.217.13.100): icmp_seq=3 ttl=57 time=10.4 ms
--- www.google.com ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 2001ms
rtt min/avg/max/mdev = 9.609/10.276/10.783/0.499 ms
&lt;/code>&lt;/pre>
&lt;p>We are live!&lt;/p>
&lt;p>&lt;strong>Note&lt;/strong>: On some distro, the &amp;lsquo;&lt;em>Shared with other computers&lt;/em>&amp;rsquo; is
not available from the default settings.
In this case fire up &lt;code>nm-connection-editor&lt;/code> from a terminal instead
of the network connections editor.&lt;/p>
&lt;h2 id="set-a-static-mac-address">Set a static MAC address&lt;/h2>
&lt;p>Because we are connecting our Pi Zero as an Ethernet device through
USB OTG, each time the connection is established the board is issued
with a new random MAC address. This can be quickly annoying if we rely
on the MAC address for, e.g. assigning a static IP to our board directly
in our router configurations.
This set up it totally &lt;strong>optional&lt;/strong>.&lt;/p>
&lt;p>In the &lt;code>boot&lt;/code> partition, edit the file &lt;code>cmdline.txt&lt;/code> and append at the end,&lt;/p>
&lt;pre>&lt;code class="language-terminal">g_ether.host_addr=aa:bb:cc:dd:ee:ff
&lt;/code>&lt;/pre>
&lt;p>where &lt;code>aa:bb:cc:dd:ee:ff&lt;/code> will be the static MAC address.
We can use for instance the last mac address assigned to the board.
To retrieve it, run &lt;code>ifconfig&lt;/code> on the host machine and look for a
connection along the lines &lt;code>enp0s29xxxxx&lt;/code>.&lt;/p>
&lt;h2 id="set-a-static-ip-address">Set a static IP address&lt;/h2>
&lt;p>We can also choose to assign a static IP address to our board so that we don&amp;rsquo;t
have to look for it every now and then.
To set a static IP address, edit the file &lt;code>/etc/dhcpcd.conf&lt;/code> as follows,&lt;/p>
&lt;pre>&lt;code class="language-terminal">interface usb0
static ip_address=10.42.0.42
static routers=10.42.0.1
&lt;/code>&lt;/pre>
&lt;p>Where &lt;code>10.42.0.42&lt;/code> is your desired static IP address.&lt;/p>
&lt;p>Reboot and have fun!&lt;/p></description></item></channel></rss>